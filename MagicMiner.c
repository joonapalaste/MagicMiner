/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : JIPsoft (Joona I Palaste)
 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/asl.h>
#include <libraries/dos.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <devices/gameport.h>
#include <devices/inputevent.h>
#include <devices/timer.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#include "MagicMiner.h"

struct Screen         *Scr = NULL;
APTR                   VisualInfo = NULL;
struct Window         *MagicMinerWnd = NULL;
struct Gadget         *MagicMinerGList = NULL;
struct Menu           *MagicMinerMenus = NULL;
struct IntuiMessage    MagicMinerMsg;
struct Gadget         *MagicMinerGadgets[9];
UWORD                  MagicMinerLeft = 0;
UWORD                  MagicMinerTop = 0;
UWORD                  MagicMinerWidth = 320;
UWORD                  MagicMinerHeight = 256;
UBYTE                 *MagicMinerWdt = (UBYTE *)"Magic Miner v1.0";

struct TextAttr topaz8 = {
        ( STRPTR )"topaz.font", 8, 0x00, 0x01 };

struct IntuiText MagicMinerIText[] = {
        1, 0, JAM1,16, 215, &topaz8, (UBYTE *)"Keys:", &MagicMinerIText[1],
        1, 0, JAM1,216, 215, &topaz8, (UBYTE *)"Mode:", NULL };

struct NewMenu MagicMinerNewMenu[] = {
        NM_TITLE, (STRPTR)"Game", NULL, 0, NULL, NULL,
        NM_ITEM, (STRPTR)"Load level...", (STRPTR)"L", 0, 0L, (APTR)MagicMinerLoad,
        NM_ITEM, (STRPTR)"About...", (STRPTR)"A", 0, 0L, (APTR)MagicMinerAbout,
        NM_ITEM, (STRPTR)"Quit...", (STRPTR)"Q", 0, 0L, (APTR)MagicMinerQuit,
        NM_END, NULL, NULL, 0, 0L, NULL };

UWORD MagicMinerGTypes[] = {
        TEXT_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND
};

struct NewGadget MagicMinerNGad[] = {
        32, 226, 265, 11, NULL, NULL, GD_Message, 0, NULL, NULL,
        72, 205, 25, 11, (UBYTE *)"Lives:", NULL, GD_Lives, PLACETEXT_LEFT, NULL, NULL,
        152, 205, 25, 11, (UBYTE *)"Time:", NULL, GD_Time, PLACETEXT_LEFT, NULL, NULL,
        264, 205, 25, 11, (UBYTE *)"Diamonds:", NULL, GD_Diamonds, PLACETEXT_LEFT, NULL, NULL,
        80, 213, 25, 11, (UBYTE *)"B", NULL, GD_Blue, PLACETEXT_LEFT, NULL, NULL,
        128, 213, 25, 11, (UBYTE *)"G", NULL, GD_Green, PLACETEXT_LEFT, NULL, NULL,
        176, 213, 25, 11, (UBYTE *)"R", NULL, GD_Red, PLACETEXT_LEFT, NULL, NULL,
        96, 197, 25, 11, (UBYTE *)"Level #", NULL, GD_Level, PLACETEXT_LEFT, NULL, NULL,
        200, 197, 65, 11, (UBYTE *)"Score:", NULL, GD_Score, PLACETEXT_LEFT, NULL, NULL
};

ULONG MagicMinerGTags[] = {
        (GTTX_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE)
};

UWORD DriPens[] = {
        ~0 };

struct MsgPort *port=NULL;
struct IOStdReq *req=NULL;
struct timeval tv;
ULONG secs,secs0,secs1;
LONG micro,micro0,micro1;
UBYTE type=GPCT_ABSJOYSTICK;
struct GamePortTrigger *gpt;
struct InputEvent *ie;
struct Image *image[258];
struct RastPort hidden_rp;
struct BitMap *hidden_bm=NULL;
UBYTE shadecolour,shadedir,gtl;
BYTE plrx,plry,oplrx,oplry,boxx,boxy;
UWORD diamonds;
struct level *level[256];
struct level *currentlevel=NULL;
/* Array declarations. These are copied straight from the AMOS original. */
UBYTE l2p[72]=
{ 0, 1, 3, 5, 7, 9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,28,30,
 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,66,70,74,75,76,
 77,78,79,81,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102};
UBYTE p2l[103];
UBYTE blev[103]=
{0,0,0,0,0,0,0,1,1,2,2,2,2,0,0,0,2,2,2,2,2,2,3,3,
 3,3,1,1,2,2,1,1,0,0,0,0,0,1,0,1,1,1,0,2,2,3,2,3,
 3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,3,3,2,2,1,3,3,1,1,2,2,2,2,2,2,2,2,2,2,3,3,2,
 2,3,3,3,3,1,0};
BYTE lev[4][72]=
{ 0, 1, 2, 3, 8, 9,10,24,25,26,27,28,30,34,71,-1,-1,-1,-1,-1,-1,-1,-1,-1,
 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  0, 1, 2, 3, 4, 8, 9,10,21,23,24,25,26,27,28,29,30,31,32,33,34,42,43,44,
 49,51,70,71,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,21,22,23,24,25,26,27,
 28,29,30,31,32,33,34,35,36,38,42,43,44,47,48,49,51,52,53,54,55,56,57,58,
 59,60,61,64,65,70,71,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,
 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71};
UBYTE prop[72]=
{1,2,2,2,2,1,2,1,0,2,2,2,2,2,2,2,2,0,
 0,0,0,2,2,2,1,1,1,0,0,0,0,0,0,0,1,1,
 1,1,1,1,1,1,0,0,1,6,5,6,6,0,0,6,6,6,
 6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,6,6,6};
BYTE adir[8][2]=
{-1, 0, 1, 0, 0,-1, 0, 1,
 -1,-1,-1, 1, 1,-1, 1, 1};
UBYTE maxblock[4]={15,28,55,72};
UBYTE *leveldata=NULL;
UBYTE *specialmap=NULL;
UBYTE *specialdata=NULL;
UBYTE *tempdata=NULL;
UBYTE inuse[256],key[3],kreq[3];
UBYTE current,cur2,gravity,base,new,new2,moveforced=0,fall=0,spacemode=0,newtwo;
UBYTE face=0,plrblock=0,dest,n;
UBYTE efall=0,eface=0,nmeblock=0,nmedir=RIGHT,nmecount=0,freshchange;
BYTE nmex,nmey,onmex,onmey;
BYTE dx,dy,edx,edy,cy,ddx,ddy,chx,chy,sgrav;
UBYTE ekey[3];
UWORD diamond,selblock;
LONG meter[8]={0,0,0,0,0,0,0,0};
UBYTE spacecolour[8]={0,26,14,20,2,32,13,71};
ULONG joy;
UBYTE character;

void *allocvec(ULONG length,ULONG flags)
{
    return (void *)AllocVec(length,flags);
}

/* Block attribute functions. These will be used mainly in constructing the
   levels and playing the game. */
UBYTE ob(UBYTE x,UBYTE y)
{
    return *(leveldata+x+40*y);
}
UBYTE rock2(UBYTE o)
{
    return (o>=1 && o<=10) || (o>=14 && o<=21);
}
UBYTE rock(UBYTE x,UBYTE y)
{
    return rock2(ob(x,y));
}
UBYTE liquid2(UBYTE o)
{
    return (o>=26 && o<=31);
}
UBYTE liquid(UBYTE x,UBYTE y)
{
    return liquid2(ob(x,y));
}
UBYTE grid2(UBYTE o)
{
    return (o>=50 && o<=65);
}
UBYTE grid(UBYTE x,UBYTE y)
{
    return grid2(ob(x,y));
}
UBYTE horiz2(UBYTE o)
{
    return (o>=66 && o<=69);
}
UBYTE horiz(UBYTE x,UBYTE y)
{
    return horiz2(ob(x,y));
}
UBYTE vert2(UBYTE o)
{
    return (o>=70 && o<=73);
}
UBYTE vert(UBYTE x,UBYTE y)
{
    return vert2(ob(x,y));
}
UBYTE hollow(UBYTE n)
{
    return prop[n]&1;
}
UBYTE solid(UBYTE n)
{
    return (prop[n]&2)/2;
}
UBYTE special(UBYTE n)
{
    return (prop[n]&4)/4;
}
UBYTE specialblock(UBYTE n)
{
    return (n==81 || n==82 || n==92 || n==96 || n==101);
}
UBYTE gridno(UBYTE n)
{
    return (n==50 || n==53 || n==55 || n==56 || n==57 || (n>=59 && n<=65));
}
UBYTE gridyes(UBYTE n)
{
    return (n==51 || n==52 || n==54 || n==58);
}

/* Initialises some arrays needed by the program. */
void initarrays()
{
    UWORD i;
    for (i=0; i<103; i++)
        p2l[i]=0;
    for (i=0; i<72; i++)
        p2l[l2p[i]]=i;
    for (i=0; i<103; i++)
        if (!p2l[i] && i)
            p2l[i]=p2l[i-1];
    for (i=0; i<256; i++)
        level[i]=NULL;
    tempdata=allocvec(9230,MEMF_CLEAR);
}

/* Sends an IO command to the device associated with the IO request, and returns
   without waiting for completion. */
void io(UWORD command,ULONG length,APTR data)
{
    req->io_Command=command;
    req->io_Length=length;
    req->io_Data=data;
    SendIO(req);
}

/* Tries to set up gameport.device for reading an absolute joystick. Returns
   TRUE if successful, FALSE if failed. */
UBYTE setupgameport()
{
    if (!(port=CreateMsgPort()))
        return FALSE;
    if (!(req=(struct IOStdReq *)CreateIORequest(port,sizeof(struct IOStdReq))))
        {
            DeleteMsgPort(port);
            port=NULL;
            return FALSE;
        }
    if (OpenDevice("gameport.device",1,req,0))
        {
            DeleteIORequest((struct IORequest *)req);
            req=NULL;
            DeleteMsgPort(port);
            port=NULL;
            return FALSE;
        }
    io(GPD_SETCTYPE,1,&type);
    gpt=allocvec(sizeof(struct GamePortTrigger),MEMF_CLEAR);
    gpt->gpt_Keys=GPTF_DOWNKEYS|GPTF_UPKEYS;
    gpt->gpt_XDelta=gpt->gpt_YDelta=1;
    gpt->gpt_Timeout=8;
    io(GPD_SETTRIGGER,sizeof(struct GamePortTrigger),gpt);
    io(CMD_CLEAR,0,0);
    ie=allocvec(sizeof(struct InputEvent),MEMF_CLEAR);
    return TRUE;
}

/* Undoes everything setupgameport() did, freeing up gameport.device for other
   programs. */
void closedowngameport()
{
    if (req)
        {
            AbortIO(req);
            WaitIO(req);
            CloseDevice(req);
            FreeVec(gpt); FreeVec(ie);
            DeleteIORequest((struct IORequest *)req);
            req=NULL;
            if (port)
                {
                    DeleteMsgPort(port);
                    port=NULL;
                }
        }
}

/* Reads the joystick port 1 with the gameport.device IO request, and returns a
   bitpattern of the direction. Direction bits are like in AMOS. Normal fire
   button is 0x4000, other fire buttons have different values. */
ULONG joystick()
{
    static UBYTE iosent=FALSE;
    ULONG joy=0L;
    if (!iosent)
        {
            io(GPD_READEVENT,sizeof(struct InputEvent),ie);
            iosent=TRUE;
        }
    if (CheckIO(req))
        {
            WaitIO(req);
            if (ie->ie_Y==-1)
                joy|=UP;
            if (ie->ie_X==1)
                joy|=RIGHT;
            if (ie->ie_Y==1)
                joy|=DOWN;
            if (ie->ie_X==-1)
                joy|=LEFT;
            joy|=(ie->ie_Qualifier&~15);
            io(GPD_READEVENT,sizeof(struct InputEvent),ie);
        }
    return joy;
}

/* Looks at the current system time and updates our timeval structure. */
void gettime()
{
    GetSysTime(&tv);
    secs=tv.tv_secs; micro=tv.tv_micro;
}

/* Reads a fully usable struct Image from the specified filehandle. Specify
   image dimensions and depth. After use, first FreeVec(image->ImageData),
   then FreeVec(image). */
struct Image *readimage(BPTR file,UWORD width,UWORD height,UBYTE depth)
{
    struct Image *image;
    UWORD *imagedata;
    ULONG size;
    UBYTE i;
    if (!(image=allocvec((ULONG)sizeof(struct Image),MEMF_CHIP)))
        return NULL;
    size=width*height*depth/8;
    if (!(imagedata=allocvec(size*2,MEMF_CHIP)))
        {
            FreeVec(image);
            return NULL;
        }
    if (!Read(file,imagedata,size))
        {
            FreeVec(image); FreeVec(imagedata);
            return NULL;
        }
    for (i=size-1; i; i--)
        *((UBYTE *)imagedata+2*i)=*((UBYTE *)imagedata+i);
    image->LeftEdge=0; image->TopEdge=0; image->Width=width; image->Height=height;
    image->Depth=depth; image->ImageData=(UWORD *)imagedata;
    image->PlanePick=(1<<depth)-1; image->PlaneOnOff=0; image->NextImage=NULL;
    return image;
}

/* Safely frees the given struct Image. If called with a nonexistent image
   (NULL pointer), does nothing. */
void freeimage(struct Image *image)
{
    if (image)
        {
            FreeVec(image->ImageData); image->ImageData=NULL;
            FreeVec(image); image=NULL;
        }
}

/* Loads the graphics in the accompanying data file into struct Images. */
int loadgraphics()
{
    BPTR file;
    UWORD i;
    file=Open("MagicMiner.gfx",MODE_OLDFILE);
    if (!file)
        return NULL;
    for (i=0; i<258; i++)
        image[i]=NULL;
    for (i=0; i<258; i++)
        if (!(image[i]=readimage(file,8,8,7)))
            {
                Close(file);
                return NULL;
            }
    Close(file);
    InitRastPort(&hidden_rp);
    hidden_bm=AllocBitMap(320,208,7,BMF_CLEAR,NULL);
    hidden_rp.BitMap=hidden_bm;
    shadecolour=1; shadedir=0;
    return TRUE;
}

/* Loads the palette in the accompanying data file into the screen's ViewPort. */
int loadpalette()
{
    BPTR file;
    UBYTE *data=NULL;
    if (!(data=allocvec(1544,NULL)))
        return NULL;
    file=Open("MagicMiner.pal",MODE_OLDFILE);
    if (!file)
        {
            FreeVec(data);
            return NULL;
        }
    if (Read(file,data,1544)<1544)
        {
            Close(file);
            FreeVec(data);
            return NULL;
        }
    LoadRGB32(&(Scr->ViewPort),data);
    Close(file);
    FreeVec(data);
    return TRUE;
}

/* Frees any struct Images we might have allocated. */
void cleanup()
{
    int i;
    for (i=0; i<258; i++)
        freeimage(image[i]);
    if (hidden_bm)
        {
            FreeBitMap(hidden_bm);
            hidden_bm=NULL;
        }
}

/* Allocates a new level with the specified number and difficulty. After this
   the next and prev fields must be set to the array indeces of the next and
   previous levels. These do not have to be in ascending order in the array. */
struct level *createlevel(UBYTE number,UBYTE difficulty)
{
    struct level *l;
    UBYTE *n,*d,*s,*sd;
    if (!(n=allocvec(25,MEMF_CLEAR)))
        return NULL;
    if (!(d=allocvec(1000,MEMF_CLEAR)))
        {
            FreeVec(n);
            return NULL;
        }
    if (!(s=allocvec(1000,MEMF_CLEAR)))
        {
            FreeVec(n); FreeVec(d);
            return NULL;
        }
    if (!(sd=allocvec(8192,MEMF_CLEAR)))
        {
            FreeVec(n); FreeVec(d); FreeVec(s);
            return NULL;
        }
    if (!(l=allocvec(sizeof(struct level),MEMF_CLEAR)))
        {
            FreeVec(n); FreeVec(d); FreeVec(s); FreeVec(sd);
            return NULL;
        }
    l->name=n; l->data=d; l->special=s; l->specialdata=sd;
    l->plrx=0; l->plry=0; l->nmex=255; l->nmey=255;
    l->next=0; l->prev=0;
    l->number=number; l->flags=(difficulty<<4)+1;
    l->diamonds=0; l->time=300;
    return l;
}

/* Deletes the specified level from memory. If called with a nonexistant level
   (NULL pointer), does nothing. */
void freelevel(struct level *l)
{
    if (l)
        {
            if (l->name)
                FreeVec(l->name);
            if (l->data)
                FreeVec(l->data);
            if (l->special)
                FreeVec(l->special);
            if (l->specialdata)
                FreeVec(l->specialdata);
            FreeVec(l);
            l=NULL;
        }
}

/* Displays any given request with Intution EasyRequesters. */
int request(UBYTE *title,UBYTE *text,UBYTE *buttons,APTR arg)
{
    struct EasyStruct req;
    req.es_StructSize=sizeof(struct EasyStruct);
    req.es_Flags=0; req.es_Title=title;
    req.es_TextFormat=text; req.es_GadgetFormat=buttons;
    return EasyRequest(MagicMinerWnd,&req,NULL,arg);
}

/* Superimposes a struct Image over an existing struct Image on the hidden
   rastport and copies it onto the displayed rastport. ANDs existing image
   with mask and then ORs it with the actual block. */
void superimpose(UWORD mask,UWORD img,UWORD qx,UWORD qy,UWORD px,UWORD py)
{
    DrawImage(&hidden_rp,image[mask],0,200);
    ClipBlit(&hidden_rp,0,200,&hidden_rp,qx,qy,8,8,0x80);
    DrawImage(&hidden_rp,image[img],0,200);
    ClipBlit(&hidden_rp,0,200,&hidden_rp,qx,qy,8,8,0xE0);
    ClipBlit(&hidden_rp,qx,qy,MagicMinerWnd->RPort,px,py,8,8,0xC0);
}

void siobject(UBYTE object)
{
    switch (object)
        {
            case 0:
            superimpose(222+4*gravity+2*face,103+4*gravity+2*face,currentlevel->plrx*8,currentlevel->plry*8,currentlevel->plrx*8,currentlevel->plry*8);
            break;
            case 1:
            superimpose(222+4*gravity+2*eface,111+4*gravity+2*eface,currentlevel->nmex*8,currentlevel->nmey*8,currentlevel->nmex*8,currentlevel->nmey*8);
            break;
            case 2:
            superimpose(257,256,boxx*8,boxy*8,boxx*8,boxy*8);
            break;
        }
}

/* Draws a block on the level display. Uses superimpose() to do the drawing.
   Also draws player or enemy pictures if needed. */
void drawblock(UBYTE num,UBYTE x,UBYTE y)
{
    UWORD px,py,qx,qy;
    gravity=(currentlevel->flags&8)/8;
    if (gravity)
        sgrav=-1;
    else
        sgrav=1;
    px=8*x; py=8*y;
    if (y<25)
        {
            qx=px; qy=py;
        }
    else
        {
            qx=8; qy=200;
        }
    if (num!=255)
        {
            DrawImage(&hidden_rp,image[y + (y<25?230:214)],qx,qy);
            superimpose(num+119,num,qx,qy,px,py);
            if (x==currentlevel->plrx && y==currentlevel->plry)
                siobject(0);
            if (x==currentlevel->nmex && y==currentlevel->nmey)
                siobject(1);
            if (x==boxx && y==boxy)
                siobject(2);
        }
    else
        DrawImage(MagicMinerWnd->RPort,image[255],px,py);
    if (leveldata && y<25)
        *(leveldata+x+40*y)=num;
}

/* Adds a block into the actual level and draws it according to all block
   unification rules. */
void addblock(UBYTE num,UBYTE x,UBYTE y)
{
    UBYTE vrock,vliquid,u,r,d,l;
    vrock=vliquid=u=r=d=l=0;
    if (specialblock(ob(x,y)) && !specialblock(num))
        inuse[*(specialmap+x+40*y)]=FALSE;
    if (blev[num]>currentlevel->flags/16)
        num=0;
    if (!gtl)
        {
            if (ob(x,y)==42 && num!=42)
                diamonds--;
            if (ob(x,y)!=42 && num==42)
                diamonds++;
            if (currentlevel->diamonds>diamonds)
                currentlevel->diamonds=diamonds;
        }
    else
        if (ob(x,y)==42)
            diamonds++;
    if (rock2(num))
        {
            if (y<24 && !rock(x,y))
                if (rock(x,y+1) && ob(x,y+1)<14)
                    drawblock(((ob(x,y+1)-1)&254)+1,x,y+1);
            if (y)
                vrock=1-rock(x,y-1);
            else
                vrock=1;
            if (num<14)
                num=((num-1)&254|vrock)+1;
        }
    if (rock(x,y) && !rock2(num))
        if (y<24)
            if (rock(x,y+1) && ob(x,y+1)<14)
                drawblock(((ob(x,y+1)-1)|1)+1,x,y+1);
    if (liquid2(num))
        {
            if (y<24 && !liquid(x,y))
                if (liquid(x,y+1))
                    drawblock(ob(x,y+1)&254,x,y+1);
            if (y)
                vliquid=1-liquid(x,y-1);
            else
                vliquid=1;
            num=num&254|vliquid;
        }
    if (liquid(x,y) && !liquid2(num))
        if (y<24)
            if (liquid(x,y+1))
                drawblock(ob(x,y+1)|1,x,y+1);
    if (grid2(num))
        {
            if (y)
                if (u=grid(x,y-1))
                    drawblock(((ob(x,y-1)-2)|4)+2,x,y-1);
            if (x<39)
                if (r=grid(x+1,y))
                    drawblock(((ob(x+1,y)-2)|8)+2,x+1,y);
            if (y<24)
                if (d=grid(x,y+1))
                    drawblock(((ob(x,y+1)-2)|1)+2,x,y+1);
            if (x)
                if (l=grid(x-1,y))
                    drawblock(((ob(x-1,y)-2)|2)+2,x-1,y);
            num=50+u+2*r+4*d+8*l;
        }
    if (grid(x,y) && !grid2(num))
        {
            if (y)
                if (grid(x,y-1))
                    drawblock(((ob(x,y-1)-2)&251)+2,x,y-1);
            if (x<39)
                if (grid(x+1,y))
                    drawblock(((ob(x+1,y)-2)&247)+2,x+1,y);
            if (y<24)
                if (grid(x,y+1))
                    drawblock(((ob(x,y+1)-2)&254)+2,x,y+1);
            if (x)
                if (grid(x-1,y))
                    drawblock(((ob(x-1,y)-2)&253)+2,x-1,y);
        }
    if (horiz2(num))
        {
            if (x)
                if (l=horiz(x-1,y))
                    drawblock(((ob(x-1,y)-2)|2)+2,x-1,y);
            if (x<39)
                if (r=horiz(x+1,y))
                    drawblock(((ob(x+1,y)-2)|1)+2,x+1,y);
            num=66+l+2*r;
        }
    if (horiz(x,y) && !horiz2(num))
        {
            if (x)
                if (horiz(x-1,y))
                    drawblock(((ob(x-1,y)-2)&253)+2,x-1,y);
            if (x<39)
                if (horiz(x+1,y))
                    drawblock(((ob(x+1,y)-2)&254)+2,x+1,y);
        }
    if (vert2(num))
        {
            if (y)
                if (u=vert(x,y-1))
                    drawblock(((ob(x,y-1)-2)|2)+2,x,y-1);
            if (y<24)
                if (d=vert(x,y+1))
                    drawblock(((ob(x,y+1)-2)|1)+2,x,y+1);
            num=70+u+2*d;
        }
    if (vert(x,y) && !vert2(num))
        {
            if (y)
                if (vert(x,y-1))
                    drawblock(((ob(x,y-1)-2)&253)+2,x,y-1);
            if (y<24)
                if (vert(x,y+1))
                    drawblock(((ob(x,y+1)-2)&254)+2,x,y+1);
        }
    drawblock(num,x,y);
}

/* Changes the shading on the background according to the variables
   shadecolour and shadedir. */
void changeshade()
{
    ULONG *data;
    ULONG value;
    UBYTE gravity,i,r,g,b;
    if (data=allocvec(392,NULL))
        {
            *data=(ULONG)0x00200060;
            r=(shadecolour&4)/4; g=(shadecolour&2)/2; b=shadecolour&1;
            for (i=0; i<32; i++)
                {
                    if (!shadedir)
                        value=(i*8+7)<<24;
                    else
                        value=((31-i)*8+7)<<24;
                    *(data+3*i+1)=r*value;
                    *(data+3*i+2)=g*value;
                    *(data+3*i+3)=b*value;
                }
            *(data+97)=0L;
            LoadRGB32(&(Scr->ViewPort),data);
            FreeVec(data);
        }
    gravity=(currentlevel->flags&8)/8;
    currentlevel->flags&=~15;
    currentlevel->flags|=(shadedir*8)|shadecolour;
    if (gravity!=shadedir)
        {
            drawblock(ob(currentlevel->plrx,currentlevel->plry),currentlevel->plrx,currentlevel->plry);
            if (currentlevel->nmex!=255 && currentlevel->nmey!=255)
                drawblock(ob(currentlevel->nmex,currentlevel->nmey),currentlevel->nmex,currentlevel->nmey);
        }
}

void updateplr()
{
    currentlevel->plrx=plrx; currentlevel->plry=plry;
    addblock(plrblock,oplrx,oplry);
    siobject(0);
    if (plrx==boxx && plry==boxy)
        siobject(2);
    oplrx=plrx; oplry=plry;
}

void updatenme()
{
    currentlevel->nmex=nmex; currentlevel->nmey=nmey;
    addblock(nmeblock,onmex,onmey);
    siobject(1);
    if (nmex==boxx && nmey==boxy)
        siobject(2);
    onmex=nmex; onmey=nmey;
}

/* Selects the specified level as the current level and draws it on the editor
   window. */
void gotolevel(WORD lev)
{
    UBYTE i,j,b,used,found;
    UBYTE olddif;
    UWORD k;
    if (currentlevel)
        olddif=currentlevel->flags/16;
    else
        olddif=4;
    currentlevel=level[lev];
    leveldata=currentlevel->data;
    specialmap=currentlevel->special;
    specialdata=currentlevel->specialdata;
    for (k=0; k<256; k++)
        inuse[k]=FALSE;
    gtl=TRUE; diamonds=0; used=FALSE; found=FALSE;
    for (i=0; i<40; i++)
        for (j=0; j<25; j++)
            {
                b=ob(i,j);
                if (b==79 && !used)
                    {
                        b=80; used=TRUE; selblock=i+40*j;
                    }
                if (b==94 || b==98)
                    found=TRUE;
                addblock(b,i,j);
                if (specialblock(*(leveldata+i+40*j)))
                    inuse[*(specialmap+i+40*j)]=TRUE;
            }
    gtl=FALSE;
    if (found)
        {
            boxx=0; boxy=0; siobject(2);
        }
    else
        {
            boxx=255; boxy=255;
        }
    shadedir=(currentlevel->flags&8)/8;
    shadecolour=currentlevel->flags&7;
    changeshade();
    secs0=0L; micro0=0L; secs1=0L; micro1=0L;
}

void swap(UBYTE *first,UBYTE *second)
{
    UBYTE auxiliary;
    auxiliary=*first;
    *first=*second;
    *second=auxiliary;
}

/* Returns a pseudo-random number from 0 to (maxvalue-1). */
int rnd(int maxvalue)
{
    static int seed=0;
    if (seed==0)
        {
            seed=(int)time(NULL);
            srand(seed);
        }
    return rand()%maxvalue;
}

void addtime(LONG *secsvar,LONG *microvar,LONG dsecs,LONG dmicro)
{
    *secsvar+=dsecs;
    *microvar+=dmicro;
    if (*microvar>=1000000L)
        {
            *microvar-=1000000L;
            *secsvar++;
        }
}

void subtime(LONG *secsvar,LONG *microvar,LONG dsecs,LONG dmicro)
{
    *secsvar-=dsecs;
    *microvar-=dmicro;
    if (*microvar<0L)
        {
            *microvar+=1000000L;
            *secsvar--;
        }
}

void update(UBYTE what,LONG amount)
{
    meter[what]=amount;
    GT_SetGadgetAttrs(MagicMinerGadgets[what+1],MagicMinerWnd,NULL,GTNM_Number,amount,TAG_DONE);
}

void updatespacemode(UBYTE mode)
{
    SetAPen(MagicMinerWnd->RPort,spacecolour[mode]);
    RectFill(MagicMinerWnd->RPort,267,228,285,231);
    spacemode=mode;
}

void findnextradio()
{
    UWORD i;
    if (selblock<65535)
        {
            i=selblock;
            do
                i=(i+1)%1000;
            while (*(leveldata+i)!=79 && i!=selblock);
            if (*(leveldata+i)==79)
                {
                    selblock=i;
                    addblock(80,i%40,i/40);
                }
            else
                selblock=65535;
        }
}

void dospecial(UBYTE x,UBYTE y)
{
    UBYTE o=ob(x,y);
    UBYTE n,bx,by,b,flag;
    BYTE blx,bly,nx,ny;
    UWORD bn,i;
    UBYTE *bdata;
    UBYTE *msg;
    chx=0; chy=0;
    if (o==81 || o==82 || o==92 || o==96 || o==101)
        {
            n=*(specialmap+x+40*y);
            bdata=specialdata+32*n;
            if (o==81 || o==82)
                {
                    bx=*bdata; by=*(bdata+1);
                    b=ob(bx,by);
                    if (b==80)
                        findnextradio();
                    if (*(bdata+2)==79 && selblock==65535)
                        {
                            *(bdata+2)=80; selblock=bx+40*by;
                        }
                    addblock(*(bdata+2),bx,by);
                    *(bdata+2)=b;
                    addblock(o^3,x,y);
                }
            if (o==92 || o==96)
                {
                    bx=*bdata; by=*(bdata+1);
                }
            if (o==101)
                {
                    msg=allocvec(33,MEMF_CLEAR);
                    CopyMem(bdata,msg,32);
                    request("Message","%s","Proceed",msg);
                    FreeVec(msg);
                }
        }
    if (o>=83 && o<=90)
        updatespacemode(o-83);
    if (o==76 || o==77)
        {
            shadedir=o-76; gravity=shadedir;
            if (shadedir)
                sgrav=-1;
            else
                sgrav=1;
            changeshade();
        }
    if (o>=91 && o<=98)
        {
            flag=TRUE;
            if (o==91 || o==95)
                do
                    {
                        bx=rnd(40); by=rnd(25);
                    }
                while (!hollow(p2l[ob(bx,by)]));
            if (o==93 || o==97)
                {
                    bn=x+40*y; i=bn;
                    do
                        i=(i+1)%1000;
                    while (*(leveldata+i)!=93 && *(leveldata+i)!=97);
                    bx=i%40; by=i/40;
                }
            if (o==94 || o==98)
                if (hollow(p2l[ob(boxx,boxy)]))
                    {
                        bx=boxx; by=boxy;
                    }
                else
                    flag=FALSE;
            if (flag)
                {
                    if (character==PLAYER)
                        {
                            chx=bx-plrx; chy=by-plry;
                        }
                    else
                        {
                            chx=bx-nmex; chy=by-nmey;
                        }
                    new=p2l[ob(bx,by)]; new2=ob(bx,by);
                }
        }
    if (o==74)
        {
            addblock(79,selblock%40,selblock/40);
            findnextradio();
        }
    if (o==75)
        {
            if (selblock<65535)
                {
                    blx=selblock%40; bly=selblock/40;
                    nx=blx+dx; ny=bly+dy;
                    if (nx>=0 && nx<=39 && ny>=0 && ny<=24 && (nx!=blx || ny!=bly))
                        {
                            b=p2l[ob(nx,ny)];
                            if (!b || b==22 || b==23)
                                {
                                    addblock(0,blx,bly);
                                    if (!b)
                                        {
                                            addblock(80,nx,ny);
                                            selblock=nx+40*ny;
                                        }
                                    else
                                        findnextradio();
                                }
                        }
                }
            chx=0; chy=0;
        }
    if (o==99)
        {
            if (boxx<255)
                {
                    blx=boxx; bly=boxy;
                    nx=boxx+dx; ny=boxy+dy;
                    if (nx>=0 && nx<=39 && ny>=0 && ny<=24 && (nx!=boxx || ny!=boxy))
                        {
                            boxx=nx; boxy=ny;
                            addblock(ob(blx,bly),blx,bly);
                            siobject(2);
                        }
                }
            chx=0; chy=0;
        }
    if (character==PLAYER)
        {
            dx=chx; dy=chy;
        }
    else
        {
            edx=chx; edy=chy;
        }
}

int move()
{
    character=PLAYER;
    joy=joystick();
    dx=0; dy=0;
    if (joy&UP)
        dy=-1;
    if (joy&RIGHT)
        dx=1;
    if (joy&DOWN)
        dy=1;
    if (joy&LEFT)
        dx=-1;
    if (joy&FIRE)
        dospecial(plrx,plry);
    current=p2l[ob(plrx,plry)]; cur2=ob(plrx,plry);
    if (plry+sgrav>=0 && plry+sgrav<=24)
        base=p2l[ob(plrx,plry+sgrav)];
    else
        base=1;
    if (plrx+dx<0 || plrx+dx>39)
        dx=0;
    if (plry+dy<0 || plry+dy>24)
        dy=0;
    new=p2l[ob(plrx+dx,plry+dy)]; new2=ob(plrx+dx,plry+dy);
    if (base==4 && fall)
        addblock(0,plrx,plry+sgrav);
    if (base==21 || base==22)
        return FALSE;
    moveforced=FALSE;
    if (current==19 || current==20)
        if (!solid(new) || new!=(current^1))
            {
                cy=-1+2*(current-19); dest=p2l[ob(plrx,plry+cy)];
                if (!solid(dest))
                    {
                        dx=0; dy=cy; moveforced=TRUE;
                        new=p2l[ob(plrx+dy,plry+dy)]; new2=ob(plrx+dx,plry+dy);
                    }
            }
    fall=FALSE;
    if (current!=8 && current!=42 && current!=43 && hollow(base))
        if (base<35 || base>41 || spacemode&(base-34))
            {
                dx=0; dy=sgrav; fall=TRUE; moveforced=TRUE;
                new=p2l[ob(plrx+dx,plry+dy)]; new2=ob(plrx+dx,plry+dy);
            }
    if (new>=60 && new<=63)
        dospecial(plrx+dx,plry+dy);
    if (gridno(cur2) && new!=42)
        {
            dx=0; dy=0;
        }
    if (current!=42 && gridno(new2))
        {
            dx=0; dy=0;
        }
    if (current==43 || new==43)
        dy=0;
    if (current==44 || new==44)
        dx=0;
    if (current==17 || current==18)
        {
            cy=-1+2*(current-17);
            if (dy*cy==-1)
                {
                    dx=0; dy=0;
                }
        }
    if (solid(new))
        {
            ddx=dx; ddy=dy;
            dx=0; dy=0;
            if (special(new))
                dospecial(plrx+ddx,plry+ddy);
        }
    if (new>=24 && new<=26)
        {
            key[new-24]++; addblock(0,plrx+dx,plry+dy); update(BLUE+new-24,meter[BLUE+new-24]+1);
        }
    if (new==34)
        {
            diamond++; addblock(0,plrx+dx,plry+dy);
            if (meter[DIAMONDS])
                {
                    update(SCORE,meter[SCORE]+5); update(DIAMONDS,meter[DIAMONDS]-1);
                }
            else
                update(SCORE,meter[SCORE]+10);
        }
    if (new>=27 && new<=34)
        {
            n=new-26; kreq[2]=(n&4)/4; kreq[1]=(n&2)/2; kreq[0]=n&1;
            if (key[0]>=kreq[0] && key[1]>=kreq[1] && key[2]>=kreq[2])
                {
                    key[0]-=kreq[0]; key[1]-=kreq[1]; key[2]-=kreq[2];
                    update(BLUE,meter[BLUE]-kreq[0]); update(GREEN,meter[GREEN]-kreq[1]); update(RED,meter[RED]-kreq[2]);
                    addblock(0,plrx+dx,plry+dy);
                }
            else
                {
                    dx=0; dy=0;
                }
        }
    if (new>=35 && new<=41)
        if (!(spacemode & (new-34)))
            {
                dx=0; dy=0;
            }
    if (base>=9 && base<=16)
        if (dx*adir[base-9][gravity]==-1)
            {
                dx=0; dy=0;
            }
    if (new==49 || new==50)
        {
            if (dx)
                if (plrx+dx>=1 && plrx+dx<=38)
                    newtwo=p2l[ob(plrx+2*dx,plry)];
                else
                    newtwo=1;
            if (dy)
                if (plry+dy>=1 && plry+dy<=23)
                    newtwo=p2l[ob(plrx,plry+2*dy)];
                else
                    newtwo=1;
            if (!newtwo || newtwo==22 || newtwo==23)
                {
                    if (!newtwo)
                        {
                            addblock(new2,plrx+2*dx,plry+2*dy);
                            if (new2==80)
                                selblock=plrx+2*dx+40*(plry+2*dy);
                        }
                    else
                        if (new2==80)
                            findnextradio();
                    addblock(0,plrx+dx,plry+dy);
                }
            else
                {
                    dx=0; dy=0;
                }
        }
    if (dx || dy)
        {
            if (dx==1)
                face=1;
            if (dx==-1)
                face=0;
            if (base==2)
                addblock(6,plrx,plry+sgrav);
            if (base==3)
                addblock(0,plrx,plry+sgrav);
            if (current==7)
                plrblock=1;
            oplrx=plrx; oplry=plry; plrx+=dx; plry+=dy;
            updateplr(); plrblock=ob(plrx,plry);
        }
    return TRUE;
}

void reversenme()
{
    if (nmedir==LEFT)
        nmedir=RIGHT;
    else
        if (nmedir==RIGHT)
            nmedir=LEFT;
}

void nmemove()
{
    UBYTE flag;
    character=ENEMY;
    edx=0; edy=0;
    current=p2l[ob(nmex,nmey)]; cur2=ob(nmex,nmey);
    if (nmey+sgrav>=0 && nmey+sgrav<=24)
        base=p2l[ob(nmex,nmey+sgrav)];
    else
        base=1;
    if (plry==nmey)
        if (plrx>nmex)
            edy=1;
        else
            edx=-1;
    else
        if (plrx==nmex)
            {
                if (plry<nmey && (current==8 || gridyes(cur2)))
                    edy=-1;
                if (plry>nmey && (base==8 || gridyes(l2p[base])))
                    edy=1;
            }
    if (!edx && !edy)
        switch (nmedir)
            {
                case RIGHT:
                flag=FALSE;
                if (base==8 || gridyes(l2p[base]) && plry>nmey)
                    {
                        nmedir=DOWN; freshchange=TRUE; flag=TRUE;
                    }
                if (current==8 || gridyes(cur2) && plry<nmey)
                    {
                        nmedir=UP; freshchange=TRUE; flag=TRUE;
                    }
                if (!flag)
                    edx=1;
                break;
                case DOWN:
                if (solid(base))
                    if (plrx<nmex)
                        {
                            nmedir=LEFT; edx=-1;
                        }
                    else
                        {
                            nmedir=RIGHT; edx=1;
                        }
                else
                    if (nmex>0 && nmey+sgrav>=0 && nmey+sgrav<=24)
                        if (!freshchange && solid(p2l[ob(nmex-1,nmey+sgrav)]) && (base==8 || gridyes(l2p[base])))
                            if (plrx<nmex)
                                {
                                    nmedir=LEFT; edx=-1;
                                }
                            else
                                {
                                    nmedir=RIGHT; edx=1;
                                }
                        else
                            edy=1;
                    else
                        edy=1;
                freshchange=FALSE;
                break;
                case LEFT:
                flag=FALSE;
                if (base==8 || gridyes(l2p[base]) && plry>nmey)
                    {
                        nmedir=DOWN; freshchange=TRUE; flag=TRUE;
                    }
                if (current==8 || gridyes(cur2) && plry<nmey)
                    {
                        nmedir=UP; freshchange=TRUE; flag=TRUE;
                    }
                if (!flag)
                    edx=-1;
                break;
                case UP:
                if (current!=8 && !gridyes(cur2))
                    if (plrx<nmex)
                        {
                            nmedir=LEFT; edx=-1;
                        }
                    else
                        {
                            nmedir=RIGHT; edx=1;
                        }
                else
                    if (nmex<39 && nmey+sgrav>=0 && nmey+sgrav<=24)
                        if (!freshchange && solid(p2l[ob(nmex+1,nmey+sgrav)]) && (base==8 || gridyes(l2p[base])))
                            if (plrx<nmex)
                                {
                                    nmedir=LEFT; edx=-1;
                                }
                            else
                                {
                                    nmedir=RIGHT; edx=1;
                                }
                        else
                            edy=-1;
                    else
                        edy=-1;
                freshchange=FALSE;
                break;
            }
    if (nmex+edx<0)
        {
            nmedir=RIGHT; edx=0;
        }
    if (nmex+edx>39)
        {
            nmedir=LEFT; edx=0;
        }
    if (nmey+edy<0 || nmey+edy>24)
        edy=0;
    new=p2l[ob(nmex+edx,nmey+edy)]; new2=ob(nmex+edx,nmey+edy);
    if (base==4 && efall)
        addblock(0,nmex,nmey+sgrav);
    if (base==21 || base==22)
        {
            nmex=255; nmey=255;
        }
    moveforced=FALSE;
    if (current==19 || current==20)
        if (!solid(new) || new!=(current^1))
            {
                cy=-1+2*(current-19); dest=p2l[ob(nmex,nmey+cy)];
                if (!solid(dest))
                    {
                        edx=0; edy=cy; moveforced=TRUE;
                        new=p2l[ob(nmex+edy,nmey+edy)]; new2=ob(nmex+edx,nmey+edy);
                    }
            }
    efall=FALSE;
    if (current!=8 && current!=42 && current!=43 && hollow(base))
        if (base<35 || base>41 || spacemode&(base-34))
            {
                edx=0; edy=sgrav; efall=TRUE; moveforced=TRUE;
                new=p2l[ob(nmex+edx,nmey+edy)]; new2=ob(nmex+edx,nmey+edy);
            }
    if (new>=60 && new<=63)
        dospecial(nmex+edx,nmey+edy);
    if (gridno(cur2) && new!=42)
        {
            edx=0; edy=0;
            reversenme();
        }
    if (current!=42 && gridno(new2))
        {
            edx=0; edy=0;
            reversenme();
        }
    if (current==43 || new==43)
        edy=0;
    if (current==44 || new==44)
        {
            edx=0;
            reversenme();
        }
    if (current==17 || current==18)
        {
            cy=-1+2*(current-17);
            if (edy*cy==-1)
                {
                    edx=0; edy=0;
                }
        }
    if (solid(new))
        {
            ddx=edx; ddy=edy;
            edx=0; edy=0;
            if (special(new))
                dospecial(nmex+ddx,nmey+ddy);
            reversenme();
        }
    if (new>=24 && new<=26)
        {
            ekey[new-24]++; addblock(0,nmex+edx,nmey+edy);
        }
    if (new==34)
        addblock(0,nmex+edx,nmey+edy);
    if (new>=27 && new<=34)
        {
            n=new-26; kreq[2]=(n&4)/4; kreq[1]=(n&2)/2; kreq[0]=n&1;
            if (ekey[0]>=kreq[0] && ekey[1]>=kreq[1] && ekey[2]>=kreq[2])
                {
                    ekey[0]-=kreq[0]; ekey[1]-=kreq[1]; ekey[2]-=kreq[2];
                    addblock(0,nmex+edx,nmey+edy);
                }
            else
                {
                    edx=0; edy=0;
                    reversenme();
                }
        }
    if (new>=35 && new<=41)
        if (!(spacemode & (new-34)))
            {
                edx=0; edy=0;
                reversenme();
            }
    if (base>=9 && base<=16)
        if (edx*adir[base-9][gravity]==-1)
            {
                edx=0; edy=0;
                reversenme();
            }
    if (new==49 || new==50)
        {
            if (edx)
                if (nmex+edx>=1 && nmex+edx<=38)
                    newtwo=p2l[ob(nmex+2*edx,nmey)];
                else
                    newtwo=1;
            if (edy)
                if (nmey+edy>=1 && nmey+edy<=23)
                    newtwo=p2l[ob(nmex,nmey+2*edy)];
                else
                    newtwo=1;
            if (!newtwo || newtwo==22 || newtwo==23)
                {
                    if (!newtwo)
                        {
                            addblock(new2,nmex+2*edx,nmey+2*edy);
                            if (new2==80)
                                selblock=nmex+2*edx+40*(nmey+2*edy);
                        }
                    else
                        if (new2==80)
                            findnextradio();
                    addblock(0,nmex+edx,nmey+edy);
                }
            else
                {
                    edx=0; edy=0;
                    reversenme();
                }
        }
    if (edx || edy)
        {
            if (edx==1)
                eface=1;
            if (edx==-1)
                eface=0;
            if (base==2)
                addblock(6,nmex,nmey+sgrav);
            if (base==3)
                addblock(0,nmex,nmey+sgrav);
            if (current==7)
                nmeblock=1;
            if (nmex<255 && nmey<255)
                {
                    onmex=nmex; onmey=nmey; nmex+=edx; nmey+=edy;
                    updatenme(); nmeblock=ob(nmex,nmey);
                }
            else
                {
                    currentlevel->nmex=255; currentlevel->nmey=255;
                }
        }
}

/* Allocates and shows an ASL request, and allows the user to choose a file.
   Returns the chosen filename in the UBYTE * buffer supplied in the second
   parameter. */
int aslreq(UBYTE savemode,UBYTE *namebuffer)
{
    UBYTE *p;
    UBYTE result,c=0;
    struct FileRequester *fr=NULL;
    if (fr=AllocAslRequestTags(ASL_FileRequest,
        ASLFR_Window,MagicMinerWnd,
        ASLFR_TitleText,savemode?(STRPTR)"Choose a file to save:":(STRPTR)"Choose a file to load:",
        ASLFR_PositiveText,savemode?(STRPTR)"Save":(STRPTR)"Load",
        ASLFR_NegativeText,(STRPTR)"Cancel",
        ASLFR_InitialHeight,224,
        ASLFR_InitialWidth,240,
        ASLFR_InitialLeftEdge,40,
        ASLFR_InitialTopEdge,20,
        ASLFR_DoSaveMode,(BOOL)savemode,
        TAG_DONE))
        {
            if (result=AslRequest(fr,NULL))
                {
                    for (p=fr->rf_Dir; *p; p++);
                        if (p>fr->rf_Dir)
                            c=*(p-1);
                    if (c==':' || !c)
                        sprintf(namebuffer,"%s%s",fr->rf_Dir,fr->rf_File);
                    else
                        sprintf(namebuffer,"%s/%s",fr->rf_Dir,fr->rf_File);
                }
            FreeAslRequest(fr);
        }
    return result;
}

/* Finds out the size of the file associated with the given handle. Uses an
   AmigaDOS FileInfoBlock as a measuring device. */
ULONG sizeoffile(BPTR file)
{
    struct FileInfoBlock *fib;
    ULONG size=0L;
    if (fib=allocvec(sizeof(struct FileInfoBlock),NULL))
        {
            ExamineFH(file,fib);
            size=(ULONG)fib->fib_Size;
            FreeVec(fib);
        }
    return size;
}

int SetupScreen( void )
{
        if ( ! ( Scr = OpenScreenTags( NULL, SA_Left,   0,
                                        SA_Top,         0,
                                        SA_Width,       320,
                                        SA_Height,      267,
                                        SA_Depth,       7,
                                        SA_Font,        &topaz8,
                                        SA_Type,        CUSTOMSCREEN,
                                        SA_DisplayID,   PAL_MONITOR_ID|LORES_KEY,
                                        SA_Pens,        &DriPens[0],
                                        SA_Title,       "Magic Miner v1.0 (inactive)",
                                        TAG_DONE )))
                return( 1L );

        if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
                return( 2L );

        return( 0L );
}

void CloseDownScreen( void )
{
        if ( VisualInfo ) {
                FreeVisualInfo( VisualInfo );
                VisualInfo = NULL;
        }

        if ( Scr        ) {
                CloseScreen( Scr );
                Scr = NULL;
        }
}

void MagicMinerRender( void )
{
        UWORD           offx, offy;

        offx = 0;
        offy = Scr->WBorTop + Scr->Font->ta_YSize + 1;


        DrawBevelBox( MagicMinerWnd->RPort, offx + 264, offy + 215, 25, 8, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
        DrawBevelBox( MagicMinerWnd->RPort, offx + 0, offy + 189, 321, 56, GT_VisualInfo, VisualInfo, TAG_DONE );
        PrintIText( MagicMinerWnd->RPort, MagicMinerIText, offx, offy );
}

int MagicMinerActiveWindow()
{
    gettime();
    addtime(&secs0,&micro0,secs,micro);
    subtime(&secs0,&micro0,secs1,micro1);
    return TRUE;
}
int MagicMinerInActiveWindow()
{
    gettime();
    secs1=secs; micro1=micro;
    return TRUE;
}
int MagicMinerRawKey()
{ return TRUE; }
int MagicMinerIntuiTicks()
{
    gettime();
    subtime(&secs,&micro,secs0,micro0);
    if (secs<=currentlevel->time)
        update(TIME,currentlevel->time-secs);
    if (currentlevel->nmex!=255 && currentlevel->nmey!=255 && nmecount<2)
        nmemove();
    nmecount=(nmecount+1)%3;
    return move();
}
int MagicMinerLoad()
{
    WORD i,j,len,pos;
    UBYTE *filename=NULL;
    BPTR file;
    UBYTE nn,p,pp;
    struct level *l;
    (void)MagicMinerInActiveWindow();
    if (!(filename=allocvec(256,MEMF_CLEAR)))
        return TRUE;
    if (aslreq(FALSE,filename))
        if (file=Open(filename,MODE_OLDFILE))
            {
                if (sizeoffile(file)>=1038)
                    {
                        for (i=0; i<256; i++)
                            freelevel(level[i]);
                        if (l=createlevel(0,0))
                            {
                                Read(file,tempdata,9230);
                                len=*(tempdata+1034)*256+*(tempdata+1035);
                                CopyMem(tempdata,(UBYTE *)l,10);
                                CopyMem(tempdata+10,l->name,24);
                                CopyMem(tempdata+34,l->data,1000);
                                nn=0; pos=0;
                                for (j=0; j<1000; j++)
                                    {
                                        p=*(l->data+j);
                                        if (p==81 || p==82 || p==92 || p==96 || p==101)
                                            {
                                                *(l->special+j)=nn;
                                                switch (p)
                                                    {
                                                        case 81:
                                                        case 82:
                                                        pp=3;
                                                        break;
                                                        case 92:
                                                        case 96:
                                                        pp=2;
                                                        break;
                                                        case 101:
                                                        pp=32;
                                                        break;
                                                    }
                                                CopyMem(tempdata+1036+pos,l->specialdata+32*nn,pp);
                                                pos+=pp; nn++;
                                            }
                                    }
                                level[0]=l;
                            }
                        else
                            request("Error","Out of memory creating level.","Proceed",NULL);
                        gotolevel(0);
                        update(LEVEL,(ULONG)currentlevel->number+1);
                        for (i=0; i<3; i++)
                            {
                                key[i]=0;
                                update(BLUE+i,0L);
                            }
                        updatespacemode(0);
                        update(SCORE,0L);
                        update(DIAMONDS,(ULONG)currentlevel->diamonds);
                        plrx=currentlevel->plrx; plry=currentlevel->plry;
                        oplrx=plrx; oplry=plry; dx=0; dy=0;
                        plrblock=*(l->data+plrx+40*plry);
                        nmex=currentlevel->nmex; nmey=currentlevel->nmey;
                        onmex=nmex; onmey=nmey; edx=0; edy=0;
                        nmeblock=*(l->data+nmex+40*nmey);
                    }
                else
                    request("Error","File length is too short.","Proceed",NULL);
                Close(file);
            }
        else
            request("Error","The file \"%s\"\nwas not found.","Proceed",filename);
    return TRUE;
}

int MagicMinerAbout()
{ return TRUE; }
int MagicMinerQuit()
{ return FALSE; }

int HandleMagicMinerIDCMP( void )
{
        struct IntuiMessage     *m;
        struct MenuItem         *n;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( MagicMinerWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&MagicMinerMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( MagicMinerMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( MagicMinerWnd );
                                MagicMinerRender();
                                GT_EndRefresh( MagicMinerWnd, TRUE );
                                break;

                        case    IDCMP_ACTIVEWINDOW:
                                running = MagicMinerActiveWindow();
                                break;

                        case    IDCMP_INACTIVEWINDOW:
                                running = MagicMinerInActiveWindow();
                                break;

                        case    IDCMP_RAWKEY:
                                running = MagicMinerRawKey();
                                break;

                        case    IDCMP_INTUITICKS:
                                running = MagicMinerIntuiTicks();
                                break;

                        case    IDCMP_MENUPICK:
                                while( MagicMinerMsg.Code != MENUNULL ) {
                                        n = ItemAddress( MagicMinerMenus, MagicMinerMsg.Code );
                                        func = (void *)(GTMENUITEM_USERDATA( n ));
                                        running = func();
                                        MagicMinerMsg.Code = n->NextSelect;
                                }
                                break;
                }
        }
        return( running );
}

int OpenMagicMinerWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = 0, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &MagicMinerGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < MagicMiner_CNT; lc++ ) {

                CopyMem((char * )&MagicMinerNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                MagicMinerGadgets[ lc ] = g = CreateGadgetA((ULONG)MagicMinerGTypes[ lc ], g, &ng, ( struct TagItem * )&MagicMinerGTags[ tc ] );

                while( MagicMinerGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( MagicMinerMenus = CreateMenus( MagicMinerNewMenu, GTMN_FrontPen, 0L, TAG_DONE )))
                return( 3L );

        LayoutMenus( MagicMinerMenus, VisualInfo, GTMN_TextAttr, &topaz8, TAG_DONE );

        if ( ! ( MagicMinerWnd = OpenWindowTags( NULL,
                                WA_Left,        MagicMinerLeft,
                                WA_Top,         MagicMinerTop+Scr->BarHeight+1,
                                WA_InnerWidth,  MagicMinerWidth,
                                WA_InnerHeight, MagicMinerHeight,
                                WA_IDCMP,       TEXTIDCMP|NUMBERIDCMP|IDCMP_INTUITICKS|IDCMP_MENUPICK|IDCMP_RAWKEY|IDCMP_ACTIVEWINDOW|IDCMP_INACTIVEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_SMART_REFRESH|WFLG_BACKDROP|WFLG_GIMMEZEROZERO|WFLG_BORDERLESS|WFLG_ACTIVATE,
                                WA_Gadgets,     MagicMinerGList,
                                WA_ScreenTitle, "Magic Miner v1.0  Joona \"I\" Palaste 1998-1999",
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        SetMenuStrip( MagicMinerWnd, MagicMinerMenus );
        GT_RefreshWindow( MagicMinerWnd, NULL );

        MagicMinerRender();

        return( 0L );
}

void CloseMagicMinerWindow( void )
{
        if ( MagicMinerMenus      ) {
                ClearMenuStrip( MagicMinerWnd );
                FreeMenus( MagicMinerMenus );
                MagicMinerMenus = NULL; }

        if ( MagicMinerWnd        ) {
                CloseWindow( MagicMinerWnd );
                MagicMinerWnd = NULL;
        }

        if ( MagicMinerGList      ) {
                FreeGadgets( MagicMinerGList );
                MagicMinerGList = NULL;
        }
}

main()
{
    if (!SetupScreen())
        {
            if (!OpenMagicMinerWindow())
                {
                    if (loadgraphics() && loadpalette())
                        {
                            if (setupgameport())
                                {
                                    initarrays();
                                    level[0]=createlevel(0,0);
                                    gotolevel(0);
                                    plrx=0; plry=0; oplrx=39; oplry=24;
                                    updateplr();
                                    while (HandleMagicMinerIDCMP());
                                    CloseMagicMinerWindow();
                                    closedowngameport();
                                }
                            cleanup();
                        }
                }
            CloseDownScreen();
        }
}
